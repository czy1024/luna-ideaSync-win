<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="439" />
    <option name="newTranslationDialogWidth" value="1272" />
    <option name="newTranslationDialogX" value="168" />
    <option name="newTranslationDialogY" value="25" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="此属性是其别名的属性的名称" />
      <item value="The name of the attribute that this attribute is an alias for" />
      <item value="The optional name of a method to call on the bean instance upon closing the application context, for example a close() method on a JDBC DataSource implementation, or a Hibernate SessionFactory object. The method must have no arguments but may throw any exception." />
      <item value="Is this bean a candidate for getting autowired into some other bean? Default is true; set this to false for internal delegates that are not meant to get in the way of beans of the same type in other places." />
      <item value="} factory method argument resolution and {@code @Autowired} processing supersede nametype-based bean property injection" />
      <item value="factory method argument resolution and" />
      <item value="The default mode does allow for annotation-driven autowiring. &quot;no&quot; refers to externally driven autowiring only, not affecting any autowiring demands that the bean class itself expresses through annotations." />
      <item value="Note that this autowire mode is just about externally driven autowiring based on bean property setter methods by convention, analogous to XML bean definitions." />
      <item value="Are dependencies to be injected via convention-based autowiring by name or type?" />
      <item value="Specify whether @Bean methods should get proxied in order to enforce bean lifecycle behavior, e.g. to return shared singleton bean instances even in case of direct @Bean method calls in user code. This feature requires method interception, implemented through a runtime-generated CGLIB subclass which comes with limitations such as the configuration class and its methods not being allowed to declare final." />
      <item value="the explicit component name, if any (or empty String otherwise)" />
      <item value="class is registered as a traditional XML bean definition, the nameid of the bean element will take precedence." />
      <item value="element will take precedence." />
      <item value="applies" />
      <item value="Explicitly specify the name of the Spring bean definition associated with the @Configuration class. If left unspecified (the common case), a bean name will be automatically generated." />
      <item value="This post processor is priority-ordered as it is important that any @Bean methods declared in @Configuration classes have their corresponding bean definitions registered before any other BeanFactoryPostProcessor executes." />
      <item value="A simple example with the former follows:" />
      <item value="or its web-capable variant," />
      <item value="classes are typically bootstrapped using either" />
      <item value="typically" />
      <item value="Indicates that a class declares one or more {@link Bean @Bean} methods and may be processed by the Spring container to generate bean definitions and service requests for those beans at runtime, for example:" />
      <item value="Register bean processors that intercept bean creation." />
      <item value="Allows post-processing of the bean factory in context subclasses." />
      <item value="Set a temporary ClassLoader for type matching." />
      <item value="Name of the LoadTimeWeaver bean in the factory. If such a bean is supplied, the context will use a temporary ClassLoader for type matching, in order to allow the LoadTimeWeaver to process all actual bean classes." />
      <item value="Detect a LoadTimeWeaver and prepare for weaving, if found." />
      <item value="Register early post-processor for detecting inner beans as ApplicationListeners." />
      <item value="BeanFactory interface not registered as resolvable type in a plain factory. MessageSource registered (and found for autowiring) as a bean." />
      <item value="Tell the internal bean factory to use the context's class loader etc." />
      <item value="Configure the factory's standard context characteristics, such as the context's ClassLoader and post-processors." />
      <item value="Configure the bean factory with context callbacks." />
      <item value="Prepare the bean factory for use in this context" />
      <item value="Subclasses must implement this method to perform the actual configuration load. The method is invoked by refresh() before any other initialization work. A subclass will either create a new bean factory and hold a reference to it, or return a single BeanFactory instance that it holds. In the latter case, it will usually throw an IllegalStateException if refreshing the context more than once." />
      <item value="Tell the subclass to refresh the internal bean factory." />
      <item value="Validate that all properties marked as required are resolvable: see ConfigurablePropertyResolversetRequiredProperties" />
      <item value="Replace any stub property sources with actual instances. Replace Servlet-related property sources." />
      <item value="Initialize any placeholder property sources in the context environment." />
      <item value="Flag that indicates whether this context has been closed already." />
      <item value="Flag that indicates whether this context is currently active." />
      <item value="Replaces all placeholders of format {name} with the value returned from the supplied" />
      <item value="Servlet config init parameters property source name: &quot;servletConfigInitParams&quot;." />
      <item value="Customize the set of property sources with those contributed by superclasses as well as those appropriate for standard servlet-based environments:" />
      <item value="Check whether a default JNDI environment, as in a Java EE environment, is available on this JVM. Returns: true if a default InitialContext can be used, false if not" />
      <item value="Resolve the given path, replacing placeholders with corresponding environment property values if necessary. Applied to config locations." />
      <item value="the parent context" />
      <item value="array of resource locations" />
      <item value="whether to automatically refresh the context, loading all bean definitions and creating all singletons. Alternatively, call refresh manually after further configuring the context." />
      <item value="Adds the elapsed time from the given start time (ns) to the perf counter." />
      <item value="Performance counter support for internal JRE classes. This class defines a fixed list of counters for the platform to use as an interim solution until RFE 6209222 is implemented. The perf counters will be created in the jvmstat perf buffer that the HotSpot VM creates. The default size is 32K and thus the number of counters is bounded. You can alter the size with -XX:PerfDataMemorySize=&lt;bytes&gt; option. If there is insufficient memory in the jvmstat perf buffer, the C heap memory will be used and thus the application will continue to run if the counters added exceeds the buffer size but the counters will be missing. See HotSpot jvmstat implementation for certain circumstances that the jvmstat perf buffer is not supported." />
      <item value="If true then resolve the class" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="143" />
        <entry key="ENGLISH" value="143" />
        <entry key="HINDI" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1678183553317" />
  </component>
</application>