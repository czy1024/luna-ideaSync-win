<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="439" />
    <option name="newTranslationDialogWidth" value="1272" />
    <option name="newTranslationDialogX" value="168" />
    <option name="newTranslationDialogY" value="25" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="Specify a temporary ClassLoader to use for type matching purposes. Default is none, simply using the standard bean ClassLoader. A temporary ClassLoader is usually just specified if load-time weaving is involved, to make sure that actual bean classes are loaded as lazily as possible. The temporary loader is then removed once the BeanFactory completes its bootstrap phase." />
      <item value="Scope identifier for the standard prototype scope: {@value}." />
      <item value="Specifies whether a component should be configured as a scoped proxy and if so, whether the proxy should be interface-based or subclass-based." />
      <item value="Specify whether scanned beans should be registered for lazy initialization. Default is false; switch this to true when desired." />
      <item value="The pattern (or patterns) to use for the filter, as an alternative to specifying a Class value. If type is set to ASPECTJ, this is an AspectJ type pattern expression. If type is set to REGEX, this is a regex pattern for the fully-qualified class names to match." />
      <item value="Filter candidates matching a given regex pattern." />
      <item value="Filter candidates matching a given AspectJ type pattern expression." />
      <item value="Filter candidates assignable to a given type" />
      <item value="Filter candidates marked with a given annotation." />
      <item value="Default typically equals NO, unless a different default has been configured at the component-scan instruction level." />
      <item value="Enumerates the various scoped-proxy options. For a more complete discussion of exactly what a scoped proxy is, see the section of the Spring reference documentation entitled 'Scoped beans as dependencies'." />
      <item value="Strategy interface for generating bean names for bean definitions." />
      <item value="Derive a default bean name from the given bean definition. &lt;p&gt;The default implementation simply builds a decapitalized version of the short class name: e.g. &quot;mypackage.MyJdbcDao&quot; &amp;rarr; &quot;myJdbcDao&quot;. &lt;p&gt;Note that inner classes will thus have names of the form &quot;outerClassName.InnerClassName&quot;, which because of the period in the name may be an issue if you are autowiring by name. @param definition the bean definition to build a bean name for @return the default bean name (never {@code null})" />
      <item value="Get the class name without the qualified package name." />
      <item value="Check whether the given String contains actual text. More specifically, this method returns true if the String is not null, its length is greater than 0, and it contains at least one non-whitespace character." />
      <item value="此属性是其别名的属性的名称" />
      <item value="The name of the attribute that this attribute is an alias for" />
      <item value="The optional name of a method to call on the bean instance upon closing the application context, for example a close() method on a JDBC DataSource implementation, or a Hibernate SessionFactory object. The method must have no arguments but may throw any exception." />
      <item value="Is this bean a candidate for getting autowired into some other bean? Default is true; set this to false for internal delegates that are not meant to get in the way of beans of the same type in other places." />
      <item value="} factory method argument resolution and {@code @Autowired} processing supersede nametype-based bean property injection" />
      <item value="factory method argument resolution and" />
      <item value="The default mode does allow for annotation-driven autowiring. &quot;no&quot; refers to externally driven autowiring only, not affecting any autowiring demands that the bean class itself expresses through annotations." />
      <item value="Note that this autowire mode is just about externally driven autowiring based on bean property setter methods by convention, analogous to XML bean definitions." />
      <item value="Are dependencies to be injected via convention-based autowiring by name or type?" />
      <item value="Specify whether @Bean methods should get proxied in order to enforce bean lifecycle behavior, e.g. to return shared singleton bean instances even in case of direct @Bean method calls in user code. This feature requires method interception, implemented through a runtime-generated CGLIB subclass which comes with limitations such as the configuration class and its methods not being allowed to declare final." />
      <item value="the explicit component name, if any (or empty String otherwise)" />
      <item value="class is registered as a traditional XML bean definition, the nameid of the bean element will take precedence." />
      <item value="element will take precedence." />
      <item value="applies" />
      <item value="Explicitly specify the name of the Spring bean definition associated with the @Configuration class. If left unspecified (the common case), a bean name will be automatically generated." />
      <item value="This post processor is priority-ordered as it is important that any @Bean methods declared in @Configuration classes have their corresponding bean definitions registered before any other BeanFactoryPostProcessor executes." />
      <item value="A simple example with the former follows:" />
      <item value="or its web-capable variant," />
      <item value="classes are typically bootstrapped using either" />
      <item value="typically" />
      <item value="Indicates that a class declares one or more {@link Bean @Bean} methods and may be processed by the Spring container to generate bean definitions and service requests for those beans at runtime, for example:" />
      <item value="Register bean processors that intercept bean creation." />
      <item value="Allows post-processing of the bean factory in context subclasses." />
      <item value="Set a temporary ClassLoader for type matching." />
      <item value="Name of the LoadTimeWeaver bean in the factory. If such a bean is supplied, the context will use a temporary ClassLoader for type matching, in order to allow the LoadTimeWeaver to process all actual bean classes." />
      <item value="Detect a LoadTimeWeaver and prepare for weaving, if found." />
      <item value="Register early post-processor for detecting inner beans as ApplicationListeners." />
      <item value="BeanFactory interface not registered as resolvable type in a plain factory. MessageSource registered (and found for autowiring) as a bean." />
      <item value="Tell the internal bean factory to use the context's class loader etc." />
      <item value="Configure the factory's standard context characteristics, such as the context's ClassLoader and post-processors." />
      <item value="Configure the bean factory with context callbacks." />
      <item value="Prepare the bean factory for use in this context" />
      <item value="Subclasses must implement this method to perform the actual configuration load. The method is invoked by refresh() before any other initialization work. A subclass will either create a new bean factory and hold a reference to it, or return a single BeanFactory instance that it holds. In the latter case, it will usually throw an IllegalStateException if refreshing the context more than once." />
      <item value="Tell the subclass to refresh the internal bean factory." />
      <item value="Validate that all properties marked as required are resolvable: see ConfigurablePropertyResolversetRequiredProperties" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="157" />
        <entry key="ENGLISH" value="158" />
        <entry key="HINDI" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1678183553317" />
  </component>
</application>