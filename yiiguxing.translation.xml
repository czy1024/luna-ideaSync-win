<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="439" />
    <option name="newTranslationDialogWidth" value="1272" />
    <option name="newTranslationDialogX" value="168" />
    <option name="newTranslationDialogY" value="25" />
    <histories>
      <item value="Register bean processors that intercept bean creation." />
      <item value="Allows post-processing of the bean factory in context subclasses." />
      <item value="Set a temporary ClassLoader for type matching." />
      <item value="Name of the LoadTimeWeaver bean in the factory. If such a bean is supplied, the context will use a temporary ClassLoader for type matching, in order to allow the LoadTimeWeaver to process all actual bean classes." />
      <item value="Detect a LoadTimeWeaver and prepare for weaving, if found." />
      <item value="Register early post-processor for detecting inner beans as ApplicationListeners." />
      <item value="BeanFactory interface not registered as resolvable type in a plain factory. MessageSource registered (and found for autowiring) as a bean." />
      <item value="Tell the internal bean factory to use the context's class loader etc." />
      <item value="Configure the factory's standard context characteristics, such as the context's ClassLoader and post-processors." />
      <item value="Configure the bean factory with context callbacks." />
      <item value="Prepare the bean factory for use in this context" />
      <item value="Subclasses must implement this method to perform the actual configuration load. The method is invoked by refresh() before any other initialization work. A subclass will either create a new bean factory and hold a reference to it, or return a single BeanFactory instance that it holds. In the latter case, it will usually throw an IllegalStateException if refreshing the context more than once." />
      <item value="Tell the subclass to refresh the internal bean factory." />
      <item value="Validate that all properties marked as required are resolvable: see ConfigurablePropertyResolversetRequiredProperties" />
      <item value="Replace any stub property sources with actual instances. Replace Servlet-related property sources." />
      <item value="Initialize any placeholder property sources in the context environment." />
      <item value="Flag that indicates whether this context has been closed already." />
      <item value="Flag that indicates whether this context is currently active." />
      <item value="Replaces all placeholders of format {name} with the value returned from the supplied" />
      <item value="Servlet config init parameters property source name: &quot;servletConfigInitParams&quot;." />
      <item value="Customize the set of property sources with those contributed by superclasses as well as those appropriate for standard servlet-based environments:" />
      <item value="Check whether a default JNDI environment, as in a Java EE environment, is available on this JVM. Returns: true if a default InitialContext can be used, false if not" />
      <item value="Resolve the given path, replacing placeholders with corresponding environment property values if necessary. Applied to config locations." />
      <item value="the parent context" />
      <item value="array of resource locations" />
      <item value="whether to automatically refresh the context, loading all bean definitions and creating all singletons. Alternatively, call refresh manually after further configuring the context." />
      <item value="Adds the elapsed time from the given start time (ns) to the perf counter." />
      <item value="Performance counter support for internal JRE classes. This class defines a fixed list of counters for the platform to use as an interim solution until RFE 6209222 is implemented. The perf counters will be created in the jvmstat perf buffer that the HotSpot VM creates. The default size is 32K and thus the number of counters is bounded. You can alter the size with -XX:PerfDataMemorySize=&lt;bytes&gt; option. If there is insufficient memory in the jvmstat perf buffer, the C heap memory will be used and thus the application will continue to run if the counters added exceeds the buffer size but the counters will be missing. See HotSpot jvmstat implementation for certain circumstances that the jvmstat perf buffer is not supported." />
      <item value="If true then resolve the class" />
      <item value="This method must be called after the module system initialization. The security manager and system class loader may be custom class from the application classpath or modulepath." />
      <item value="Returns an array containing Method objects reflecting all the declared methods of the class or interface represented by this Class object, including public, protected, default (package) access, and private methods, but excluding inherited methods." />
      <item value="Returns a Method object that reflects the specified declared method of the class or interface represented by this Class object. The name parameter is a String that specifies the simple name of the desired method, and the parameterTypes parameter is an array of Class objects that identify the method's formal parameter types, in declared order. If more than one method with the same parameter types is declared in a class, and one of these methods has a return type that is more specific than any of the others, that method is returned; otherwise one of the methods is chosen arbitrarily. If the name is &quot;&lt;init&gt;&quot;or &quot;&lt;clinit&gt;&quot; a NoSuchMethodException is raised." />
      <item value="The parent class loader for delegation Note: VM hardcoded the offset of this field, thus all new fields must be added after it." />
      <item value="The class of the given name is not found in the parent class loader as well as its local URLClassPath. Check if this class has already been defined dynamically; if so, return the loaded class; otherwise, skip the parent delegation and findClass." />
      <item value="To compare elapsed time against a timeout, use" />
      <item value="Returns the current value of the running Java Virtual Machine's high-resolution time source, in nanoseconds. This method can only be used to measure elapsed time and is not related to any other notion of system or wall-clock time. The value returned represents nanoseconds since some fixed but arbitrary origin time (perhaps in the future, so values may be negative). The same origin is used by all invocations of this method in an instance of a Java virtual machine; other virtual machine instances are likely to use a different origin." />
      <item value="If a security manager is present, and the caller's class loader is not {@code null}, and the caller's class loader is not the same as or an ancestor of the platform class loader, and the caller does not have the" />
      <item value="The name of the builtin platform class loader is" />
      <item value="Return the default ClassLoader to use: typically the thread context ClassLoader, if available; the ClassLoader that loaded the ClassUtils class will be used as fallback. &lt;p&gt;Call this method if you intend to use the thread context ClassLoader in a scenario where you clearly prefer a non-null ClassLoader reference: for example, for class path resource loading (but not necessarily for {@code Class.forName}, which accepts a {@code null} ClassLoader" />
      <item value="Return the default ClassLoader to use: typically the thread context ClassLoader, if available; the ClassLoader that loaded the ClassUtils class will be used as fallback. &lt;p&gt;Call this method if you intend to use the thread context ClassLoader in a scenario where you clearly prefer a non-null ClassLoader reference: for example, for class path resource loading (but not necessarily for" />
      <item value="Cannot access system ClassLoader - oh well, maybe the caller can live with null..." />
      <item value="Cannot access thread context ClassLoader - falling back..." />
      <item value="Prepare this context for refreshing." />
      <item value="instead" />
      <item value="occurred evaluating" />
      <item value="true if the permit was acquired, false otherwise" />
      <item value="Return whether this helper will validate all addresses passed to it." />
      <item value="It is important to note that the number of permits requested never affect the throttling of the request itself (an invocation to acquire(1) and an invocation to acquire(1000) will result in exactly the same throttling, if any), but it affects the throttling of the next request. I.e., if an expensive task arrives at an idle RateLimiter, it will be granted immediately, but it is the next request that will experience extra throttling, thus paying for the cost of the expensive task." />
      <item value="the duration of the period where the RateLimiter ramps up its rate, before reaching its stable (maximum) rate" />
      <item value="the rate of the returned RateLimiter, measured in how many permits become available per second" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="123" />
        <entry key="ENGLISH" value="124" />
        <entry key="HINDI" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1678183553317" />
  </component>
</application>